# Generally keep the qcCutoffs parameters unchanged. Set removeLocalOutliers to
# FALSE if you do not want to remove local outliers
myData <- setBioProbeQCFlags(myData,
qcCutoffs = list(minProbeRatio = 0.1,
percentFailGrubbs = 20),
removeLocalOutliers = TRUE)
ProbeQCResults <- fData(myData)[["QCFlags"]]
# Define QC table for Probe QC
qc_df <- data.frame(Passed = sum(rowSums(ProbeQCResults[, -1]) == 0),
Global = sum(ProbeQCResults$GlobalGrubbsOutlier),
Local = sum(rowSums(ProbeQCResults[, -2:-1]) > 0
& !ProbeQCResults$GlobalGrubbsOutlier))
## ----bioprobeQCTable, echo = FALSE, results = "asis"--------------------------
kable(qc_df, caption = "Probes flagged or passed as outliers")
## ----excludeOutlierProbes-----------------------------------------------------
#Subset object to exclude all that did not pass Ratio & Global testing
ProbeQCPassed <-
subset(myData,
fData(myData)[["QCFlags"]][,c("LowProbeRatio")] == FALSE &
fData(myData)[["QCFlags"]][,c("GlobalGrubbsOutlier")] == FALSE)
dim(ProbeQCPassed)
myData <- ProbeQCPassed
## ----aggregateCounts, eval = TRUE---------------------------------------------
# Check how many unique targets the object has
length(unique(featureData(myData)[["TargetName"]]))
# collapse to targets
target_myData <- aggregateCounts(myData)
dim(target_myData)
exprs(target_myData)[100:103, 1:4]
## ----calculateLOQ, eval = TRUE------------------------------------------------
# Define LOQ SD threshold and minimum value
cutoff <- 2
minLOQ <- 2
# Calculate LOQ per module tested
LOQ <- data.frame(row.names = colnames(target_myData))
for(module in modules) {
vars <- paste0(c("NegGeoMean_", "NegGeoSD_"),
module)
if(all(vars[1:2] %in% colnames(pData(target_myData)))) {
LOQ[, module] <-
pmax(minLOQ,
pData(target_myData)[, vars[1]] *
pData(target_myData)[, vars[2]] ^ cutoff)
}
}
pData(target_myData)$LOQ <- LOQ
head(pData(target_myData)$LOQ)
## ----LOQMat, eval = TRUE------------------------------------------------------
LOQ_Mat <- c()
for(module in modules) {
ind <- fData(target_myData)$Module == module
Mat_i <- t(esApply(target_myData[ind, ], MARGIN = 1,
FUN = function(x) {
x > LOQ[, module]
}))
LOQ_Mat <- rbind(LOQ_Mat, Mat_i)
}
# ensure ordering since this is stored outside of the geomxSet
LOQ_Mat <- LOQ_Mat[fData(target_myData)$TargetName, ]
## ----segDetectionBarplot------------------------------------------------------
# Save detection rate information to pheno data
pData(target_myData)$GenesDetected <-
colSums(LOQ_Mat, na.rm = TRUE)
pData(target_myData)$GeneDetectionRate <-
pData(target_myData)$GenesDetected / nrow(target_myData)
# Determine detection thresholds: 1%, 5%, 10%, 15%, >15%
pData(target_myData)$DetectionThreshold <-
cut(pData(target_myData)$GeneDetectionRate,
breaks = c(0, 0.01, 0.05, 0.1, 0.15,1),
labels = c("<1%", "1-5%", "5-10%", "10-15%", ">15%"))
# stacked bar plot of different cut points (1%, 5%, 10%, 15%)
ggplot(pData(target_myData),
aes(x = DetectionThreshold)) +
geom_bar(aes(fill = class)) +
geom_text(stat = "count", aes(label = ..count..), vjust = -0.5) +
theme_bw() +
scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +
labs(x = "Gene Detection Rate",
y = "Segments, #",
fill = "Segment Type")
####
####
####
## ----segTable-----------------------------------------------------------------
# cut percent genes detected at 1, 5, 10, 15
kable(table(pData(target_myData)$DetectionThreshold,
pData(target_myData)$class))
## ----filterSegments-----------------------------------------------------------
target_myData <-
target_myData[, pData(target_myData)$GeneDetectionRate >= .05]                    ########EFE excludes samples with low gene detection
pData(target_myData)[,24:27]
dim(target_myData)
target_myData@phenoData@data$class
## ----replotSankey, fig.width = 10, fig.height = 8, fig.wide = TRUE, message = FALSE, warning = FALSE----
# select the annotations we want to show, use `` to surround column names with
# spaces or special symbols
# count_mat <- count(pData(myData), `Position`, Class, Origin, Sex, Age, Strain, Call, class)
# # simplify the slide names
# count_mat$`core` <- gsub("disease", "d",
#                          gsub("normal", "n", count_mat$`Position`))
# # gather the data and plot in order: class, slide name, region, segment
# test_gr <- gather_set_data(count_mat, 1:7)
# test_gr$x <- factor(test_gr$x,
#                     levels = c("Strain","Sex", "Age", "Position", "Class","Origin", "Call"))
# # plot Sankey
# sampleoverview2 <- ggplot(test_gr, aes(x, id = id, split = y, value = n)) +
#   geom_parallel_sets(aes(fill = class), alpha = 0.5, axis.width = 0.1) +
#   geom_parallel_sets_axes(axis.width = 0.2) +
#   geom_parallel_sets_labels(color = "white", size = 4) +
#   theme_classic(base_size = 17) +
#   theme(legend.position = "bottom",
#         axis.ticks.y = element_blank(),
#         axis.line = element_blank(),
#         axis.text.y = element_blank()) +
#   scale_y_continuous(expand = expansion(0)) +
#   scale_x_discrete(expand = expansion(0)) +
#   labs(x = "", y = "") +
#   annotate(geom = "segment", x = 7.25, xend = 7.25,
#            y = 0, yend = 20, lwd = 2) +
#   annotate(geom = "text", x = 7.19, y = 7.8, angle = 90, size = 4,
#            hjust = 0.5, label = "20 segments")
#
#
# sampleoverview2
# setwd("C:/Users/edmondsonef/Desktop/R-plots/")
# tiff("sampleoverview2.tiff", units="in", width=19, height=15, res=150)
# sampleoverview2
# dev.off()
## ----goi detection------------------------------------------------------------
library(scales) # for percent
# Calculate detection rate:
LOQ_Mat <- LOQ_Mat[, colnames(target_myData)]
fData(target_myData)$DetectedSegments <- rowSums(LOQ_Mat, na.rm = TRUE)
fData(target_myData)$DetectionRate <-
fData(target_myData)$DetectedSegments / nrow(pData(target_myData))
# Gene of interest detection table
goi <- c("Kras", "Trp53", "Cd274", "Cd8a", "Cd68", "Epcam","Cre",
"Krt18", "Notch1", "Notch2", "Notch3", "Notch4","Cldn8",
"Cdk6","Msh3","Myc","Mastl", "Sox2","Cav1","Fosl1","Gata4",
"Cldn18","Capn6","Cpa1","Muc5ac","Tff1","Smad4","Sox9",
"Ptf1a","Pdx1","Nr5a2","Neurog3","Bhlha15","Krt19","Dclk1",
"Fap","Hnf1b","Krt19","Ctrb1", "Hes1", "Smad4",
"Onecut1","Onecut2","Onecut3","Cdkn1a","Prss2","Runx1","Gata6",
"Gata6", "S100a11", "Nr5a2","Agr2", "Foxa2", "Fosl1","Ets2", "Runx3")
goi_df <- data.frame(
Gene = goi,
Number = fData(target_myData)[goi, "DetectedSegments"],
DetectionRate = percent(fData(target_myData)[goi, "DetectionRate"]))
## ----tableGOI, echo = FALSE, results = "asis"---------------------------------
kable(goi_df, caption = "Detection rate for Genes of Interest", align = "c",
col.names = c("Gene", "Detection, # Segments", "Detection Rate, % of Segments"))
## ----plotDetectionRate, eval = TRUE-------------------------------------------
#Plot detection rate:
plot_detect <- data.frame(Freq = c(1, 3, 5, 10, 20, 30, 50))
plot_detect$Number <-
unlist(lapply(c(0.01, 0.03, 0.05, 0.1, 0.2, 0.3, 0.5),
function(x) {sum(fData(target_myData)$DetectionRate >= x)}))
plot_detect$Rate <- plot_detect$Number / nrow(fData(target_myData))
rownames(plot_detect) <- plot_detect$Freq
ggplot(plot_detect, aes(x = as.factor(Freq), y = Rate, fill = Rate)) +
geom_bar(stat = "identity") +
geom_text(aes(label = formatC(Number, format = "d", big.mark = ",")),
vjust = 1.6, color = "black", size = 4) +
scale_fill_gradient2(low = "orange2", mid = "lightblue",
high = "dodgerblue3", midpoint = 0.65,
limits = c(0,1),
labels = scales::percent) +
theme_bw() +
scale_y_continuous(labels = scales::percent, limits = c(0,1),
expand = expansion(mult = c(0, 0))) +
labs(x = "% of Segments",
y = "Genes Detected, % of Panel > LOQ")
## ----subsetGenes, eval = TRUE-------------------------------------------------
# Subset to target genes detected in at least 10% of the samples.
#   Also manually include the negative control probe, for downstream use
negativeProbefData <- subset(fData(target_myData), CodeClass == "Negative")
neg_probes <- unique(negativeProbefData$TargetName)
target_myData <-
target_myData[fData(target_myData)$DetectionRate >= 0.035 |                    ########EFE change to include additional genes?
fData(target_myData)$TargetName %in% neg_probes, ]
dim(target_myData)
# retain only detected genes of interest
goi <- goi[goi %in% rownames(target_myData)]
## ----previewNF, fig.width = 8, fig.height = 8, fig.wide = TRUE, eval = TRUE, warning = FALSE, message = FALSE----
library(reshape2)  # for melt
library(cowplot)   # for plot_grid
# Graph Q3 value vs negGeoMean of Negatives
ann_of_interest <- "class"
Stat_data <-
data.frame(row.names = colnames(exprs(target_myData)),
Segment = colnames(exprs(target_myData)),
Annotation = pData(target_myData)[, ann_of_interest],
Q3 = unlist(apply(exprs(target_myData), 2,
quantile, 0.75, na.rm = TRUE)),
NegProbe = exprs(target_myData)[neg_probes, ])
Stat_data_m <- melt(Stat_data, measure.vars = c("Q3", "NegProbe"),
variable.name = "Statistic", value.name = "Value")
plt1 <- ggplot(Stat_data_m,
aes(x = Value, fill = Statistic)) +
geom_histogram(bins = 40) + theme_bw() +
scale_x_continuous(trans = "log2") +
facet_wrap(~Annotation, nrow = 1) +
scale_fill_brewer(palette = 3, type = "qual") +
labs(x = "Counts", y = "Segments, #")
plt2 <- ggplot(Stat_data,
aes(x = NegProbe, y = Q3, color = Annotation)) +
geom_abline(intercept = 0, slope = 1, lty = "dashed", color = "darkgray") +
geom_point() + guides(color = "none") + theme_bw() +
scale_x_continuous(trans = "log2") +
scale_y_continuous(trans = "log2") +
theme(aspect.ratio = 1) +
labs(x = "Negative Probe GeoMean, Counts", y = "Q3 Value, Counts")
plt3 <- ggplot(Stat_data,
aes(x = NegProbe, y = Q3 / NegProbe, color = Annotation)) +
geom_hline(yintercept = 1, lty = "dashed", color = "darkgray") +
geom_point() + theme_bw() +
scale_x_continuous(trans = "log2") +
scale_y_continuous(trans = "log2") +
theme(aspect.ratio = 1) +
labs(x = "Negative Probe GeoMean, Counts", y = "Q3/NegProbe Value, Counts")
btm_row <- plot_grid(plt2, plt3, nrow = 1, labels = c("B", ""),
rel_widths = c(0.43,0.57))
plot_grid(plt1, btm_row, ncol = 1, labels = c("A", ""))
## ----normalizeObject, eval = TRUE---------------------------------------------
# Q3 norm (75th percentile) for WTA/CTA  with or without custom spike-ins
target_myData <- normalize(target_myData , data_type = "RNA",
norm_method = "quant",
desiredQuantile = .75,
toElt = "q_norm")
# Background normalization for WTA/CTA without custom spike-in
target_myData <- normalize(target_myData , data_type = "RNA",
norm_method = "neg",
fromElt = "exprs",
toElt = "neg_norm")
## ----normplot, fig.small = TRUE-----------------------------------------------
# visualize the first 10 segments with each normalization method
# boxplot(exprs(target_myData)[,1:77],
#         col = "#9EDAE5", main = "Raw Counts",
#         log = "y", names = 1:77, xlab = "Segment",
#         ylab = "Counts, Raw")
#
# boxplot(assayDataElement(target_myData[,1:77], elt = "q_norm"),
#         col = "#2CA02C", main = "Q3 Norm Counts",
#         log = "y", names = 1:77, xlab = "Segment",
#         ylab = "Counts, Q3 Normalized")
#
# boxplot(assayDataElement(target_myData[,1:77], elt = "neg_norm"),
#         col = "#FF7F0E", main = "Neg Norm Counts",
#         log = "y", names = 1:77, xlab = "Segment",
#         ylab = "Counts, Neg. Normalized")
## ----dimReduction, eval = TRUE------------------------------------------------
library(umap)
library(Rtsne)
shapes = c(15,16,17,18,19,20,21,22,23,24,25)
# update defaults for umap to contain a stable random_state (seed)
custom_umap <- umap::umap.defaults
custom_umap$random_state <- 42
# run UMAP
umap_out <-
umap(t(log2(assayDataElement(target_myData , elt = "q_norm"))),
config = custom_umap)
pData(target_myData)[, c("UMAP1", "UMAP2")] <- umap_out$layout[, c(1,2)]
umapplot <-ggplot(pData(target_myData),
aes(x = UMAP1, y = UMAP2, color = Strain, label=class, size = 20)) +
geom_point(size = 3) + geom_text(hjust=1.1, vjust=0.2)+
theme_bw()+
#theme(text = element_text(size = 10)) +
theme(legend.position="none")
umapplot
# run UMAP
umap_out <-
umap(t(log2(assayDataElement(target_myData , elt = "q_norm"))),
config = custom_umap)
umapplot <-ggplot(pData(target_myData),
aes(x = UMAP1, y = UMAP2, color = Strain, label=sample_ee, size = 20)) +
geom_point(size = 3) + geom_text(hjust=1.1, vjust=0.2)+
theme_bw()+
#theme(text = element_text(size = 10)) +
theme(legend.position="none")
umapplot
umapplot <-ggplot(pData(target_myData),
aes(x = UMAP1, y = UMAP2, color = Strain, label=dx, size = 12)) +
geom_point(size = 3) + geom_text(hjust=1.1, vjust=0.2)+
theme_bw()+
#theme(text = element_text(size = 10)) +
theme(legend.position="none")
umapplot <-ggplot(pData(target_myData),
aes(x = UMAP1, y = UMAP2, color = Strain, label=TMA_position, size = 12)) +
geom_point(size = 3) + geom_text(hjust=1.1, vjust=0.2)+
theme_bw()+
#theme(text = element_text(size = 10)) +
theme(legend.position="none")
umapplot
(target_myData)$dx
# convert test variables to factors
pData(target_myData)$testRegion <-
factor(pData(target_myData)$dx, c("KPC(R270H)_PDAC_Pancreas", "KPC(R270H)_Metastasis_Liver"))
pData(target_myData)[["slide"]] <-                                            ### Control for
factor(pData(target_myData)[["MHL"]])
assayDataElement(object = target_myData, elt = "log_q") <-
assayDataApply(target_myData, 2, FUN = log, base = 2, elt = "q_norm")
# run LMM:
# formula follows conventions defined by the lme4 package
results <- c()
for(status in c("Full ROI")) {
ind <- pData(target_myData)$segment == status
mixedOutmc <-
mixedModelDE(target_myData[, ind], elt = "log_q",
modelFormula = ~ testRegion + (1 + testRegion | slide),
#modelFormula = ~ testRegion + (1 | slide),
groupVar = "testRegion",
nCores = parallel::detectCores(),
multiCore = FALSE)
r_test <- do.call(rbind, mixedOutmc["lsmeans", ])
tests <- rownames(r_test)
r_test <- as.data.frame(r_test)
r_test$Contrast <- tests
r_test$Gene <-
unlist(lapply(colnames(mixedOutmc),
rep, nrow(mixedOutmc["lsmeans", ][[1]])))
r_test$Subset <- status
r_test$FDR <- p.adjust(r_test$`Pr(>|t|)`, method = "fdr")
r_test <- r_test[, c("Gene", "Subset", "Contrast", "Estimate",
"Pr(>|t|)", "FDR")]
results <- rbind(results, r_test)
}
results$Color <- "NS or FC < 0.5"
results$Color[results$`Pr(>|t|)` < 0.05] <- "P < 0.05"
results$Color[results$FDR < 0.05] <- "FDR < 0.05"
results$Color[results$FDR < 0.001] <- "FDR < 0.001"
results$Color[abs(results$Estimate) < 0.5] <- "NS or FC < 0.5"
results$Color <- factor(results$Color,
levels = c("NS or FC < 0.5", "P < 0.05",
"FDR < 0.05", "FDR < 0.001"))
dplyr::count(results, FDR < 0.05)
head(results)
results$invert_P <- (-log10(results$`Pr(>|t|)`)) * sign(results$Estimate)
top_g <- c()
for(cond in c("Full ROI")) {
ind <- results$Subset == cond
top_g <- c(top_g,
results[ind, 'Gene'][
order(results[ind, 'invert_P'], decreasing = TRUE)[1:50]],
results[ind, 'Gene'][
order(results[ind, 'invert_P'], decreasing = FALSE)[1:50]])
}
top_g <- unique(top_g)
top_g
head(top_g)
#reverse log fold change to fit with label
results$Estimate1 <- results$Estimate*(-1)
# Graph results
ggplot(results,                                                             ###CHANGE
aes(x = Estimate1, y = -log10(`Pr(>|t|)`),
color = Color, label = Gene)) +
geom_vline(xintercept = c(0.5, -0.5), lty = "dashed") +
geom_hline(yintercept = -log10(0.05), lty = "dashed") +
geom_point() +
labs(x = " <- log2(FC) -> ",                                       ###CHANGE
y = "Significance, -log10(P)",
color = "Significance") +
scale_color_manual(values = c(`FDR < 0.001` = "dodgerblue", `FDR < 0.05` = "lightblue",
`P < 0.05` = "orange2",`NS or FC < 0.5` = "gray"),
guide = guide_legend(override.aes = list(size = 4))) +
scale_y_continuous(expand = expansion(mult = c(0,0.05))) +
#geom_text_repel(data = subset(results, Gene %in% top_g & FDR < 0.01),
geom_text_repel(data = subset(results, Gene %in% top_g & FDR < 0.1),
size = 6, point.padding = 0.15, color = "black",
min.segment.length = .1, box.padding = .2, lwd = 2,
max.overlaps = 50) +
theme_bw(base_size = 15) +
theme(legend.position = "bottom")
# Graph results
ggplot(results,                                                             ###CHANGE
aes(x = Estimate1, y = -log10(`Pr(>|t|)`),
color = Color, label = Gene)) +
geom_vline(xintercept = c(0.5, -0.5), lty = "dashed") +
geom_hline(yintercept = -log10(0.05), lty = "dashed") +
geom_point() +
labs(x = " <- log2(FC) -> ",                                       ###CHANGE
y = "Significance, -log10(P)",
color = "Significance") +
scale_color_manual(values = c(`FDR < 0.001` = "dodgerblue", `FDR < 0.05` = "lightblue",
`P < 0.05` = "orange2",`NS or FC < 0.5` = "gray"),
guide = guide_legend(override.aes = list(size = 4))) +
scale_y_continuous(expand = expansion(mult = c(0,0.05))) +
#geom_text_repel(data = subset(results, Gene %in% top_g & FDR < 0.01),
geom_text_repel(data = subset(results, Gene %in% top_g & p < 0.1),
size = 6, point.padding = 0.15, color = "black",
min.segment.length = .1, box.padding = .2, lwd = 2,
max.overlaps = 50) +
theme_bw(base_size = 15) +
theme(legend.position = "bottom")
# Graph results
ggplot(results,                                                             ###CHANGE
aes(x = Estimate1, y = -log10(`Pr(>|t|)`),
color = Color, label = Gene)) +
geom_vline(xintercept = c(0.5, -0.5), lty = "dashed") +
geom_hline(yintercept = -log10(0.05), lty = "dashed") +
geom_point() +
labs(x = " <- log2(FC) -> ",                                       ###CHANGE
y = "Significance, -log10(P)",
color = "Significance") +
scale_color_manual(values = c(`FDR < 0.001` = "dodgerblue", `FDR < 0.05` = "lightblue",
`P < 0.05` = "orange2",`NS or FC < 0.5` = "gray"),
guide = guide_legend(override.aes = list(size = 4))) +
scale_y_continuous(expand = expansion(mult = c(0,0.05))) +
#geom_text_repel(data = subset(results, Gene %in% top_g & FDR < 0.01),
geom_text_repel(data = subset(results, Gene %in% top_g),# & FDR < 0.1),
size = 6, point.padding = 0.15, color = "black",
min.segment.length = .1, box.padding = .2, lwd = 2,
max.overlaps = 50) +
theme_bw(base_size = 15) +
theme(legend.position = "bottom")
###
###
### TO DO LIST:
### 1. GLMM model to include path grades as continuous variables
###   > fm2 <- lmer(Reaction ~ Days + (Days || Subject), sleepstudy)
###
### 2. Normalization methods comparison:
###   a. Q3 (
###       - Des's methods excluded more genes vs "vignettes/GeoMxWorkflows"
###   b. Negative normal
###
###
library(knitr)
library(dplyr)
library(ggforce)
library(GeoMxWorkflows)
library(NanoStringNCTools)
library(GeomxTools)
library(readxl)
library(enrichplot)
library(data.table)
library(fgsea)
library(ggplot2)
library(ggrepel)
library(org.Hs.eg.db)
library(org.Mm.eg.db)
library(AnnotationHub)
library(GOSemSim)
library(clusterProfiler)
library(GOSemSim)
library(ggwordcloud)
library(ggplot2)
library(cowplot)
library(ReactomePA)
library(DOSE)
library(msigdbr)
library(knitr)
library(dplyr)
library(ggforce)
library(GeoMxWorkflows)
library(NanoStringNCTools)
library(GeomxTools)
library(readxl)
library(topGO)
library(GeomxTools)
library(Seurat)
library(SpatialDecon)
library(patchwork)
#https://satijalab.org/seurat/articles/de_vignette.html
library(DESeq2)
library(MAST)
# load("C:/Users/edmondsonef/Desktop/DSP GeoMx/KPC_geoMX.RData")
# assayDataElementNames(target_myData)
#
# mySeurat <- as.Seurat.NanoStringGeoMxSet(target_myData, normData = "q_norm")
# mySeurat
load("C:/Users/edmondsonef/Desktop/DSP GeoMx/Results/KPC_seurat.RData")
head(mySeurat, 3)
mySeurat@misc[1:8]
head(mySeurat@misc$sequencingMetrics)# sequencing metrics
head(mySeurat@misc$QCMetrics$QCFlags) # QC metrics
head(mySeurat@assays$GeoMx@meta.features) # gene metadata
VlnPlot(mySeurat, features = "nCount_GeoMx", pt.size = 5)
mySeurat <- as.Seurat.NanoStringGeoMxSet(target_myData, normData = "q_norm", ident = "dx3.KPC")
VlnPlot(mySeurat, features = "nCount_GeoMx", pt.size = 5)
mySeurat <- FindVariableFeatures(mySeurat)
mySeurat <- ScaleData(mySeurat)
mySeurat <- RunPCA(mySeurat, assay = "GeoMx", verbose = FALSE)
mySeurat <- FindNeighbors(mySeurat, reduction = "pca", dims = seq_len(30))
#mySeurat <- FindClusters(mySeurat, verbose = FALSE)
mySeurat <- RunUMAP(mySeurat, reduction = "pca", dims = seq_len(30))
DimPlot(mySeurat, reduction = "umap", pt.size = 5, label = TRUE, group.by = "dx3.KPC")
levels(mySeurat)
levels(x = mySeurat) <- c("Normal acini", "ADM","PanIN","Carcinoma", "Metastasis")
features <- c("Kras","Trp53","Cre","Pdx1",
"Pdia2","Cel", "Reg1","Pnliprp1","Try4",
"Hnf1b","Sox9","Krt19","Onecut1")#
list <- c("Nestin","Ncald", "St8sia3", "Camk2n1", "Atrnl1", "Spock3", "Rasgrf1")
fig <- RidgePlot(mySeurat, sort = T, #split.by = "dx3.KPC",
#idents = c("Metastasis","Carcinoma", "PanIN","ADM","Bystander","Normal acini"),
idents = c("Metastasis","Carcinoma", "PanIN3","PanIN2", "PanIN1", "ADM","Bystander","Normal acini"),
#idents = c("7-metastasis", "6-PDAC","5-PanINhi","4-PanINlo","3-ADM","2-Bystander","1-Normal acini"),
features = features, ncol = 5)
fig
features <- c("Nestin","Ncald", "St8sia3", "Camk2n1", "Atrnl1", "Spock3", "Rasgrf1")
fig <- RidgePlot(mySeurat, sort = T, #split.by = "dx3.KPC",
#idents = c("Metastasis","Carcinoma", "PanIN","ADM","Bystander","Normal acini"),
idents = c("Metastasis","Carcinoma", "PanIN3","PanIN2", "PanIN1", "ADM","Bystander","Normal acini"),
#idents = c("7-metastasis", "6-PDAC","5-PanINhi","4-PanINlo","3-ADM","2-Bystander","1-Normal acini"),
features = features, ncol = 5)
fig
features <- c("Nes","Ncald", "St8sia3", "Camk2n1", "Atrnl1", "Spock3", "Rasgrf1")
fig <- RidgePlot(mySeurat, sort = T, #split.by = "dx3.KPC",
#idents = c("Metastasis","Carcinoma", "PanIN","ADM","Bystander","Normal acini"),
idents = c("Metastasis","Carcinoma", "PanIN3","PanIN2", "PanIN1", "ADM","Bystander","Normal acini"),
#idents = c("7-metastasis", "6-PDAC","5-PanINhi","4-PanINlo","3-ADM","2-Bystander","1-Normal acini"),
features = features, ncol = 5)
fig
